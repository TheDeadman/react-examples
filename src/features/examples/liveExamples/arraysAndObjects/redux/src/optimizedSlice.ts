import { createSelector, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "redux/store";
import heroData from './hardcoded-data.json';

// The slice owns the data types that are contained in the state that it manages.
export type Filter = { attr: string; complexity: number; text: string };

type HeroRole = 'Carry' | 'Escape' | 'Nuker' | 'Disabler' | 'Support' | 'Initiator' | 'Durable' | 'Jungler' | 'Pusher';

export type HeroData = {
    id: string;
    name: string;
    localized_name: string;
    primary_attr: 'agi' | 'str' | 'int';
    attack_type: 'Melee' | 'Ranged';
    roles: HeroRole[];
    legs: number;
    complexity?: number;
    hidden?: boolean;
}

type HeroListState = {
    loadingState: 'loading' | 'refreshing' | 'done' | 'error';
    heroes: HeroData[];
    selectedHero: string;
    filter: Filter;
    useSimulatedSlowdown: boolean;
}

const initialState: HeroListState = {
    loadingState: 'loading',
    heroes: [],
    selectedHero: '',
    filter: { attr: '', complexity: 0, text: '' },
    useSimulatedSlowdown: false
};

// Re-usable function for mapping heroes based on the filter.
const filterHeroes = (heroes: HeroData[], filter: Filter) => {
    return heroes.map((hero) => {
        if ((filter.complexity !== 0 && hero.complexity !== filter.complexity) || (hero.localized_name.indexOf(filter.text) === -1)) {
            hero.hidden = true;
        } else {
            hero.hidden = false;
        }
        return hero
    })
}

export const dotaHeroListSlice = createSlice({
    name: "optimizedDotaHeroes",
    initialState,
    reducers: {
        // The reducers are all of the state manipulating logic that we previously had to include in the main component in our memoized examples. 
        // They live near the state and allow the components to call easily human readable functions. It is suggested that you put "business logic" into reducers when possible as oppose to running logic in a component then "dispatching" the result of said logic.
        setLoadingState: (state, action: PayloadAction<'loading' | 'refreshing' | 'done' | 'error'>) => {
            state.loadingState = action.payload;
        },
        setAllHeroes: (state, action: PayloadAction<HeroData[]>) => {
            state.loadingState = 'done';
            const mappedHeroes = action.payload.map(hero => {
                hero.hidden = false;
                let complexity = heroData.find(hero2 => hero2.id === parseInt(hero.id))?.complexity;
                if (complexity) {
                    hero.complexity = complexity;
                }
                return hero;
            });
            state.heroes = mappedHeroes;
        },
        setSelectedHero: (state, action: PayloadAction<string>) => {
            state.selectedHero = action.payload;
        },
        setFilterAttribute: (state, action: PayloadAction<string>) => {
            if (state.filter.attr === action.payload) {
                state.filter.attr = ''
            } else {
                state.filter.attr = action.payload;
            }
        },
        setFilterComplexity: (state, action: PayloadAction<number>) => {
            if (state.filter.complexity === action.payload) {
                state.filter.complexity = 0;
            } else {
                state.filter.complexity = action.payload;
            }
            state.heroes = filterHeroes(state.heroes, state.filter);
        },
        setFilterText: (state, action: PayloadAction<string>) => {
            state.filter.text = action.payload;
            state.heroes = filterHeroes(state.heroes, state.filter);
        },
        setUseSimulatedSlowdown: (state, action: PayloadAction<boolean>) => {
            state.useSimulatedSlowdown = action.payload
        }
    },
});

// Exporting our actions that get generated by createSlice. The action names match their corresponding reducers.
export const { setLoadingState, setAllHeroes, setSelectedHero, setFilterAttribute, setFilterComplexity, setFilterText, setUseSimulatedSlowdown } = dotaHeroListSlice.actions;

export const selectLoadingState = (state: RootState) => state.optimizedDotaHeroes.loadingState;
export const selectAllHeroes = (state: RootState) => state.optimizedDotaHeroes.heroes;

// This is a function that returns a memoized state call based on an attribute. The vast majority of the time, you would be using createSeletor directly as oppose to returning it in a function.
// Look at the "selectIntelligenceHeroes" example below for the more common use case.
export const selectHeroesByAttribute = (attr: string) => {
    return createSelector(
        [selectAllHeroes],
        (heroes) => {
            console.log("ATTR IS", attr);
            return heroes.filter(hero => hero.primary_attr === attr)
        }
    );
}


// If a component has selectIntelligenceHeroes, the component will re-render if "state.optimizedDotaHeroes.heroes" is updated.
// Because this function uses .filter, this function will return a new array every time it is called.
// The component could never memoize based on this selector because it would always be a new object.
// This includes if something else in the component caused it to update. If it's parent re-rendered, this would get run again and return a new array even if nothing in the component changed.
const selectIntelligenceHeroes = (state: RootState) => state.optimizedDotaHeroes.heroes.filter(hero => hero.primary_attr === "int")

// This example is similar to the previous except that it is memoized using "createSelector". 
// It is similar to the example above in that it will cause components using it to re-render if "state.optimizedDotaHeroes.heroes" is updated.
// The difference is that if the component using it updates for another reason, like it's parent component re-rendering or a different state variable changing, then this returns the same array that the component already has.
// This means that child components memoizing based on this array would not re-render. Also, any "useEffects" based on this array would not have to run again.
const selectMemoizedIntelligenceHeroes = createSelector(
    // Dependency array. This is an array of selectors that the memoized selector subscribes to. You can have as many selectors here as needed. 
    // The result of the selectors then become the parameters for the function after the array in the same order that they are in the array.
    // Any time that there is an update via one of the selectors, the memoized selector will re-run and notify its subscribers.
    [selectAllHeroes],
    (heroes) => {
        return heroes.filter(hero => hero.primary_attr === "int")
    }
);


export const selectSelectedHero = (state: RootState) => state.optimizedDotaHeroes.selectedHero;
export const selectFilter = (state: RootState) => state.optimizedDotaHeroes.filter;
export const selectPrimaryAttrFilter = (state: RootState) => state.optimizedDotaHeroes.filter.attr;
export const selectUseSimlatedSlowdown = (state: RootState) => state.optimizedDotaHeroes.useSimulatedSlowdown;

export default dotaHeroListSlice.reducer;